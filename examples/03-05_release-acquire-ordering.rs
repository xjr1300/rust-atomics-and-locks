//! # ReleaseとAcquireメモリオーダリング
//!
//! Releaseはストア（書き込み）操作に適用される。
//! その目的は「データを解放（Release）して、他のスレッドがデータを読み込めるようにする」ことである。
//!
//! 一方、Acquireはロード（読み込み）操作に適用される。
//! これは、他のスレッドがReleaseストア操作によって解放したデータを獲得（Acquire）して読み込むことを意味する。
//!
//! ## 観測（Observation）
//!
//! **観測**とは、あるロード操作が、どのストア操作によって書き込まれた値を読み込んだかを示す概念である。
//! つまり、「ロード（読み込み）がどのストア（書き込み）の結果を見たか」という対応関係（read-from関係）を示す。
//!
//! メモリモデルでは、すべてのそれぞれのロードには、必ずその値を書き込んだストアが先行して存在する。
//! 次の図では、`-->`が`read-from`（読み取り元）関係である。
//!
//! ```text
//! store(x, 1) --> load(x) == 1
//! ```
//!
//! ロードがストアの結果を読み取ったとき、ロードはそのストアを「観測した」という。
//!
//! ## ReleaseとAcquireの例
//!
//! 例えばスレッドAがある変数に対するストアを行い、スレッドBが同じ変数をロードする場合を考える。
//!
//! ```rust
//! static X: AtomicI32 = AtomicI32::new(0);
//!
//! // スレッドA
//! std::thread::spawn(|| {
//!     X.store(1, Release);
//! });
//!
//! // スレッドB
//! std::thread::spqwn(|| {
//!     let x = X.load(Acquire);    // Acquireであることに注意
//! });
//! ```
//!
//! 実行結果として、次の2通りの観測が考えられる。
//!
//! - `x == 1`の場合、スレッドBはAのストアを観測した。
//! - `x == 0`の場合、スレッドBは初期値のストアを観測した。
//!
//! ## 先行発生関係（happens-before）
//!
//! AcquireロードがReleaseストアの結果を観測した場合、その間に**先行発生関係（happens-before）**が成立する。
//! すなわち、Releaseストアおよびそれに**先行するすべての操作**は、Acquireロードおよびそれに**後続するすべての操作**よりも前に起こったとみなされる。
//!
//! ただし、これは「命令がこの順で実行されることを保証する」という**未来のスケジュール保証**ではなく、
//! 実行結果から「このような順序関係を持っていた」と説明できる**実行時の関係**であることに注意が必要である。
//!
//! ## Release-Acquireの関係図
//!
//! ```text
//! [Thread A]                          [Thread B]
//! --------------------------------    --------------------------------
//!   store(DATA, 123, Relaxed)
//!   store(READY, true, Release)  ----> load(READY, Acquire)
//!                                          │
//!                                          ▼
//!                                      load(DATA, Relaxed) == 123
//!
//!  └─────────────── happens-before ────────────────┘
//! ```
//!
//! ## メモリオーダリングの種類
//!
//! Acquireを読み込み更新操作（`fetch_update`）や、比較更新操作（`compare_exchange`など）に適用した場合、値をロード操作するときに適用される。
//! また、Releaseは、値をストア操作するときに適用される。
//! さらに、AcqRelは、AcquireとReleaseの組み合わせで、ロード操作ではAcquireが適用され、ストア操作ではReleaseが適用される。
//!
//! ## CPUレベルでの実行順序と、メモリモデルにおける観測可能性
//!
//! 例えば次のようなコードがある場合、CPUの最適化（命令の最順序化）により、実際の実行順序がプログラムの記述順とは異なることがある。
//!
//! ```rust
//! // 別スレッド
//! // メインスレッドのAcquireロード命令と、このスレッドのReleaseストア命令により、Release-Acquire関係が成立している。
//! let _ = thread::spawn(|| {
//!     // このストア命令が後回しにされることがある（Relaxedでは実行順序保証がない）
//!     DATA.store(123, Relaxed);
//!     // このストア命令が先に実行されることがある（CPUが命令を並び替える場合があるため）
//!     READY.store(true, Release);
//! });
//!
//! // メインスレッド
//! while !READY.load(Acquire) {
//!     // 上記ロード命令が`true`を読み込むまでは、別スレッドのReleaseストアとそれより前の操作を観測できない。
//!     thread::sleep(Duration::from_millis(100));
//!     println!("waiting...");
//! }
//! ```
//!
//! 重要なことは、CPUが内部でどの順番で命令を実行したかではなく、**他のスレッドからどう見えるか（観測可能か）**である。
//!
//! この例では、メインスレッドの`READY.load(Acquire)`が`true`を観測したとき、その値を書き込んだ別スレッドの
//! `READY.store(true, Release)`とそれに先行するすべての書き込み（この場合、`DATA.store(123, Relaxed)`）
//! が観測可能になる。
//!
//! 逆に、メインスレッドで`READY`の値がまだ`false`の間は、`Release`ストア命令が観測可能になっていないため、
//! 別スレッドの`DATA.store(123, Relaxed)`の結果も、メインスレッドからは観測できない。
//!
//! したがって、上記のコードでは、別スレッドのすべてのストア命令が実行され、メインスレッドが
//! `READY.store(true, Release)`を観測した後に、初めてメインスレッドが別スレッドの結果を観測できる。
//!
//! 操作（演算）結果を観測できる／できないを決めているのは**メモリモデル**である。
//! そのルールをハードウェア（CPU）とコンパイラーが実装して、プログラマーがプログラムで観測できる／できないを**指定**する。
//!
//! プログラマーは、`Release`、`Acquire`、`Relaxed`を指定して、操作結果をほかスレッドから観測できるようにしたり、観測できないように指定する。
//!
//! メモリモデルは、`Release`を観測した`Acquire`は、`Release`ストアの前の操作をすべて観測できるといった関係をルールで決めている。
//!
//! コンパイラは、メモリモデルが決定したルールを実現するために、命令を最適化するとともに、フェンスを挿入する。
//!
//! ハードウェア（CPU）は、処理性能を向上させるために、命令を投機的に実行して、順序を並び替えることがあるため、キャッシュ、ストアバッファ、フェンスを使用して観測可能性を制御する。
//!
//! ストアバッファとは、CPU内部にあるバッファで、CPUが値の書き込み操作を実行したとき、直接メモリに書き込むのではなく、まずストアバッファに値を書き込む。
//! ストアバッファの内容は、順次メモリに反映される。
//! この結果、同じCPUコアでは書き込み済みの値を読める一方で、他のコアからは古い値（未反映のメモリ）しか見えないという状態が起こる。
//!
//! フェンス（メモリバリア）とは、特定の命令より前に発行されたメモリアクセスをすべて完了させるための仕組みである。
use std::sync::atomic::{
    AtomicBool, AtomicU32,
    Ordering::{Acquire, Relaxed, Release},
};
use std::thread;
use std::time::Duration;

static DATA: AtomicU32 = AtomicU32::new(0);
static READY: AtomicBool = AtomicBool::new(false);

fn main() {
    thread::spawn(|| {
        DATA.store(123, Relaxed);
        READY.store(true, Release); // このストアよりも前に起こったことはすべて・・・
    });
    while !READY.load(Acquire) {
        // 上記ロードが`true`を読み込んだ後、別スレッドのRelease（`true`を読み取っているため当然）と、
        // それより前に起こったことを観測できる
        thread::sleep(Duration::from_millis(100));
        println!("waiting...");
    }
    // ここに到達したら、DATAは123になっており、0であるはずはない。
    println!("{}", DATA.load(Relaxed));
}
