//! # 真空から取り出した値（Out-of-Thin-Air）
//!
//! ## 実行順序の直感的な理解
//!
//! 1. 2つのスレッドは、最初に0を読み込む（ただし`Relaxed`であるため、他のスレッドから見て「どちらが先に書いたか」という順序は保証されない）。
//! 2. それぞれが0を書き込むため、直感的には最終的に`X=0`、`Y=0`となるように思われる。
//!
//! ## メモリモデルでの理解
//!
//! **循環的推論（cyclic reasoning）**が許されるため、`X=37`、`Y=37`という結果があり得る（実際には、具体的な37でなく任意の値）。
//!
//! ### 循環的な因果関係の例
//!
//! **1. スレッドaが`X=37`を読み込む**
//!
//! スレッドaが`X`から`37`を読み込んだとする。
//! その`37`はスレッドbが`X`に`37`を書き込んだ結果である。
//!
//! **2. スレッドbが`X`に`37`を書き込んだ理由**
//!
//! スレッドbは`Y`の値を読み込み、その値（`37`）を`X`に書き込んだ。
//! では、その`37`はどこから来たのか？ それはスレッドaが`Y`に`37`を書き込んだ結果である。
//!
//! **3. スレッドaが`Y`に`37`を書き込んだ理由**
//!
//! スレッドaが`X`から`37`を読み込んだから——という循環が成立する。
//!
//! このように、「それぞれの読み込みは他方が書き込んだ結果である」という自己完結した説明が可能になってしまう。
//!
//! ## メモリモデル上の取り扱い
//!
//! C/C++やRustのメモリモデル（**実際のメモリモデル**）では、「全体として矛盾がなければ、そのような状態を許してよい」とされている。
//! つまり、局所的に循環していても、**全体の時間的順序に明確な矛盾がなければ**その結果を許してしまうことがある。
//!
//! これを**Out-of-Thin-Air（OOTA）問題**（「薄い空気から値が生まれる問題」）と呼ぶ。
//! この現象は理論的には禁止すべきであるが、実際のメモリモデルでは完全に排除されていない。
//!
//! 理論的に厳密なメモリモデルでは、因果関係の循環は矛盾として扱われ、アサーションは成功する（`X=Y=0`になる）。
//! しかし、`Relaxed`を許す実際のメモリモデルでは、循環依存を排除できないため、`X`と`Y`が両方とも`37`などになるような状態を許し、アサーションが失敗する可能性がある。
//!
//! ## まとめ
//!
//! | 観点 | 内容 |
//! | --- | --- |
//! | 問題の本質 | `Relaxed`な読み書きには他スレッドに対する順序保証がないため、循環的な依存が生じ得る |
//! | 理論モデル | 因果関係の循環は矛盾とみなされ、アサーションは成功する（`X=Y=0`） |
//! | 現実モデル | 実装の自由度を高めるため、そのような結果（`X=Y=37`など）も理論上は許される |
//!
//! 実際のメモリモデルにおいて、`Ordering::Relaxed`は論理的・直感的な順序を期待してはならない。
//! 一貫した順序が必要な場合は、`Ordering::SeqCst`などのメモリーオーダーを使用すべきである。
//!
//! なお、実際のハードウェアやコンパイラの実装においては、「真空から取り出した値（Out-of-Thin-Air）」問題が実際に発生することはないよう設計されている。
//! このため、**現実の環境では理論モデルに近い振る舞いを示し、このコードでアサーションが失敗する可能性は事実上存在しない**。
use std::sync::atomic::{AtomicI32, Ordering::Relaxed};
use std::thread;

static X: AtomicI32 = AtomicI32::new(0);
static Y: AtomicI32 = AtomicI32::new(0);

fn main() {
    let a = thread::spawn(|| {
        let x = X.load(Relaxed);
        Y.store(x, Relaxed);
    });
    let b = thread::spawn(|| {
        let y = Y.load(Relaxed);
        X.store(y, Relaxed);
    });
    a.join().unwrap();
    b.join().unwrap();

    // 次の2つのアサーションは失敗する可能性がある？
    assert_eq!(X.load(Relaxed), 0);
    assert_eq!(Y.load(Relaxed), 0);
}
