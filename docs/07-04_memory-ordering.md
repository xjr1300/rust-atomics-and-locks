# 7.4 メモリオーダリング

> Acquire操作は後続するメモリ操作と入れ替えてはならない。
> また、Release操作は先行するメモリ操作と入れ替えてはならない。
> こうしないと、`Mutex`で守られたデータに、`Mutex`を取得する前や解放した後にアクセスしてしまうかもしれない。
> こうなるとデータ競合が発生する。

## AcquireとRelease操作

**Acquire操作**

例: `lock()`、`load(Ordering::Acquire)`

→ この操作以降のメモリアクセスが、Acquire操作より前に再順序化（リオーダリング）されてはならない。

**Release操作**

例: `unlock()`、`store(Ordering::Release)`

→ この操作以前のメモリアクセスが、Release操作より後に再順序化されてはならない。

これらは、コンパイラ最適化やCPUによる命令の再順序化を制限するためのルールである。

## 「Acquire操作は後続するメモリ操作と入れ替えてはならない」の意味

```text
Acquire操作
    ↓
通常のメモリアクセス
```

上記の順序が、他スレッドからも一貫して観測されることが保証される。
つまり、「`Mutex`を取得する前に、`Mutex`によって保護されたデータへのアクセスが実行されたかのように観測される」現象が起きてはならないということである。

## 「Release操作は先行するメモリ操作と入れ替えてはならない」の意味

```text
通常のメモリアクセス
    ↓
Release操作
```

同様に、「`Mutex`を解放した後に、`Mutex`によって保護されたデータへのアクセスが実行されたかのように観測される」現象が起きてはならないことを意味する。

## `Mutex`における例

```text
lock()    // Acquire操作
    ↓
// データアクセス
    ↓
unlock()  // Release操作
```

もし、`Acquire`による制約が破られた場合、次のような再順序化が起こり得る。

```text
// データアクセス（❌️：ロック取得前に実行されたかのように観測される）
    ↓
lock()    // Acquire操作
```

また、`Release`による制約が破られた場合、次のような再順序化が起こり得る。

```text
unlock()  // Release操作
    ↓
// データアクセス（❌️：ロック解放後に実行されたかのように観測される）
```

## 「こうなるとデータ競合が発生する」の意味

`Mutex`は、「ロックを保持している間だけ、共有データにアクセスする」という排他制御の契約を提供する。

もし、AcquireやReleaseの制約が破られた場合、次のような契約違反が発生する。

- ロックを取得する前に共有データにアクセスしたかのように観測される
- ロックを解放した後に共有データにアクセスしたかのように観測される

その結果、別スレッドと同時に同一の共有データにアクセスし、かつ少なくとも一方が書き込みを行う状況が発生する可能性がある。
これは、**データ競合（`data race`）**である。
